#pragma config(Sensor, in1,    potentiometer,  sensorPotentiometer)
#pragma config(Motor,  port2,           rightMotor,    tmotorVex269_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port4,           clawMotor,     tmotorServoStandard, openLoop)
#pragma config(Motor,  port5,           tailMotor,     tmotorVex269_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port6,           armMotor,      tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port9,           leftMotor,     tmotorVex269_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//THis defines the slots for button states, so we can see when they go up or down
enum BUTTONS{
    BUTTON5UPPER,
    BUTTON5LOWER,
    BUTTON6UPPER,
    BUTTON6LOWER,
    BUTTON7LEFT,
    BUTTON7RIGHT,
    BUTTON7UP,
    BUTTON7DOWN,
    BUTTON8LEFT,
    BUTTON8RIGHT,
    BUTTON8UP,
    BUTTON8DOWN
};

//This is where we store the button state.  0 is up, 1 is down
int bs[12]={0,0,0,0,0,0,0,0,0,0,0,0};

//Check if a button has changed state or is depressed.
//    Return  1 (>0) when a button is first pressed
//    Return -1 (<0) when a button is first pressed
//    Return  0 if the state has not changed
int chkButton (int cs, int btn) {
	if (cs && !bs[btn]) {
		bs[btn] = 1;
		return 1; //This button just went down
	} else if (!cs && bs[btn]) {
		bs[btn] = 0;
		return -1; //button was just released
	}

	return 0; //This button state has not changed
}

int clawOpen = 0;
int armPos = 0;
int targetArm = 0;
int doArmMove = 0;
int armSpeed = 100;

task ArmMove() {
	while (true) {

		armPos = SensorValue(potentiometer);

		if (!doArmMove) {
			wait1Msec(20);
			continue;
		}

		if (armPos > targetArm) {
				while (doArmMove && armPos > targetArm) {
					motor[armMotor] = -armSpeed;
					armPos = SensorValue(potentiometer);
					wait1Msec(10);
				}
				motor[armMotor] = 0;
				doArmMove = 0;
		} else {
			while (doArmMove && armPos < targetArm) {
					motor[armMotor] = armSpeed;
					armPos = SensorValue(potentiometer);
					wait1Msec(10);
				}
				motor[armMotor] = 10;
				wait1Msec(100);

				motor[armMotor] = 0;
				doArmMove = 0;
		}
	}
}

//This Task controls the ARM
task Arm() {

	motor[clawMotor] = 0;

	while(true) {
		int b7u = chkButton(vexRT[Btn7U], BUTTON7UP);
		int b7d = chkButton(vexRT[Btn7D], BUTTON7DOWN);
		int b7r = chkButton(vexRT[Btn7R], BUTTON7RIGHT);
		int b7l = chkButton(vexRT[Btn7L], BUTTON7LEFT);
		int b5d = chkButton(vexRT[Btn5D], BUTTON5LOWER);
		int b6d = chkButton(vexRT[Btn6D], BUTTON6LOWER);

		if (1 == b7u && armPos > 1300) {
			targetArm = 1000; //armPos - 200;
			armSpeed = 100;
			doArmMove = 1;
		} else if (1 == b7d && armPos < 2350) {
			targetArm = 2350; //armPos + 200;
			armSpeed = 100;
			doArmMove = 1;
		} else if (1 == b5d && armPos > 1300) {
			targetArm = 1000; //armPos - 200;
			armSpeed = 40;
			doArmMove = 1;
		} else if (1 == b6d && armPos < 2350) {
			targetArm = 2350; //armPos + 200;
			armSpeed = 40;
			doArmMove = 1;
		} else if (-1 == b5d || -1 == b6d) {
			doArmMove = 0;
		}

		if (1 == b7r || 1 == b7l) {
			motor[clawMotor] = clawOpen ? 0 : -127;
			clawOpen = 1-clawOpen;
		}

		//int goVal =
		//motor[armMotor] = goVal > 4000 ? 127 : goVal * 127 / 4000;

		wait1Msec(20);
	}

}

//Ignore the joystick becaus eit may float around the middle.  ANything less than DEADZONE is considered
//not a real value
#define JSDEADZONE 20

//This is the functionto control driving the robot. IN this case a 3 Omniwheeled Bot
void Drive()
{
		// This is the robot heading, in radians.  Direction is based on X,Y grid,  0 degrees is right,
		//  90 Stratight ahead ahead, 180 left, and 270  is directly behind.
		float Direction = 0;
		float Velocity = 127; //Motor speed, -127 to 127
		float rot = 0; //Rotational moro speed, -127 to 127

		if (vexRT[Btn5U]) {
			Direction = degreesToRadians(180); //Strafe Left
		} else if (vexRT[Btn6U]) {
			Direction = degreesToRadians(0); //Strafe Right
		} else {
			// Grab current right joystick vertical and horizontal values
			int vX = vexRT[Ch1];
			int vY = vexRT[Ch2];

			// Check absolute value (unsigned) to ensure they are not in the deadzone)
			if (abs(vX) < JSDEADZONE) vX = 0;
			if (abs(vY) < JSDEADZONE) vY = 0;

			// Overall robot velocity. Velocity is the hypoteneuse of the X=vX,vY Triangle
			// A positive Velocity means we are moving forward, negative, backwards.
			Velocity = sqrt((vX*vX)+(vY*vY)) * (vX <0 ? -1:1);

			// Using ARCTangent to get the direction of Velocity.  arctangent divides by X, so we have to make sure it is non-zero
			if (vX) {
				Direction = atan(vY/vX);
			} else {
				// if no X, then we are either moving straight up (90) or down if vY < 0
				Direction  = degreesToRadians(vY < 0 ? 270: 90);
			}
		}

		// Check to see if we are adding in rotation from left stick.  Rotation speed is the same for each wheel,
		// since they circle the robot
		rot = -vexRT[Ch4];
		if (abs(rot) < JSDEADZONE) rot = 0;

		// Mix roation in with driving.  We can't exceed max motor speed, so we may have to dial back Velocity to add
		// ability to add motor speed for rotation.  Get the magnitude of total motor speed needed, adn give Velocity
		// and roation each their proportional add-in for motor speed
		float magnitude = abs(Velocity) + abs(rot);
		if (magnitude) {
			Velocity = Velocity * abs(Velocity) / magnitude ;
		 	rot = rot * abs(rot) / magnitude;
		}

		// Calculate the speed for each motor by getting its vector for the direction the motor is placed
		float rs = (Velocity * cos(degreesToRadians(120)-Direction));  //Right wheel aims at 120 degrees
		float ls = (Velocity * cos(degreesToRadians(240)-Direction)); //Left aims at 240.
		float	ts = (Velocity * cos(/*degreesToRadians(0)*/-Direction));  //Tail wheel aims at 0

		// Assign the speed to each motor, mixing velocity and rotation
		motor[rightMotor] = rs + rot;
		motor[leftMotor] = ls + rot;
		motor[tailMotor] = ts + rot;

		wait1Msec(20);
}

task main()
{

	startTask(Arm);
	startTask(ArmMove);
	while (true) {
		Drive();
		wait1Msec(20);
	}
	stopTask(Arm);
}
